package com.test.demo.htstrix;import com.netflix.hystrix.HystrixCommandGroupKey;import com.netflix.hystrix.HystrixObservableCommand;import rx.Observable;import rx.Observer;import rx.Subscriber;import rx.Subscription;import rx.functions.Action1;import rx.observables.BlockingObservable;import rx.schedulers.Schedulers;import java.util.Iterator;import java.util.concurrent.Future;/** * @author 赵乾泽 * @version 1.0 * @title * @description * @created 2020/7/12 8:00 下午 * @changeRecord */public class HelloWorldHystrixObservableCommandDemo extends HystrixObservableCommand<String> {    private String name;    public HelloWorldHystrixObservableCommandDemo(String name){        super(HystrixCommandGroupKey.Factory.asKey("ExampleGroup"));        this.name = name;    }    private static void call(String v) {        System.out.println("onNext: " + v);    }    @Override    protected Observable<String> construct() {        return Observable.create(new Observable.OnSubscribe<String>() {            @Override            public void call(Subscriber<? super String> observer) {                try {                    if (!observer.isUnsubscribed()) {                        // a real example would do work like a network call here                        observer.onNext("Hello");//                        int i = 1/0;                        observer.onNext(name + "!");                        observer.onNext("no way");                        observer.onCompleted();                    }                } catch (Exception e) {                    observer.onError(e);                }            }        } ).subscribeOn(Schedulers.io());    }    /**     * 回调方法     * @return     */    @Override    protected Observable<String> resumeWithFallback() {        return Observable.create((Observable.OnSubscribe<String>) observer -> {            try {                if (!observer.isUnsubscribed()) {                    // a real example would do work like a network call here                    observer.onNext("Hello fallback");                    observer.onCompleted();                }            } catch (Exception e) {                observer.onError(e);            }        }).subscribeOn(Schedulers.io());    }    public static void main(String[] args) throws InterruptedException {        // 响应式编程，observe: 获取hot observable        /**         * 返回的是Hot Observable,HotObservable，不论 “事件源” 是否有“订阅者”         * 都会在创建后对事件进行发布。所以对于Hot Observable的每一个“订阅者”都有         * 可能从“事件源”的中途开始的，并可能只是看到了整个操作的局部过程         */        HelloWorldHystrixObservableCommandDemo worldHystrixDemo = new HelloWorldHystrixObservableCommandDemo("world");        HelloWorldHystrixObservableCommandDemo bobHystrixDemo = new HelloWorldHystrixObservableCommandDemo("bob");        Observable<String> fworld = worldHystrixDemo.observe();        Observable<String> fbob = bobHystrixDemo.observe();        Iterator<String> iterator = fworld.toBlocking().getIterator();        while (iterator.hasNext()){            System.out.println(iterator.next());        }        //注意：因为执行是异步的，所以要想看到输出结果这里就要阻塞一下        Thread.sleep(3000);        // 每次订阅，命令重放        fworld.subscribe(HelloWorldHystrixObservableCommandDemo::call, Throwable::printStackTrace);        // non-blocking        // - also verbose anonymous inner-class        // - ignore errors and onCompleted signal        fbob.subscribe(v -> System.out.println("onNext: " + v));        // 响应式编程，toObservable: 获取cold observable        /**         * Cold Observable在没有 “订阅者” 的时候并不会发布时间，         * 而是进行等待，知道有 “订阅者” 之后才发布事件，所以对于         * Cold Observable的订阅者，它可以保证从一开始看到整个操作的全部过程。         */        HelloWorldHystrixObservableCommandDemo unSubHystrixDemo = new HelloWorldHystrixObservableCommandDemo("unsub");        Observable<String> funsub = unSubHystrixDemo.toObservable();        System.out.println(funsub.toBlocking().first());    }}